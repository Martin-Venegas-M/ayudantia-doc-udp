---
title: "ManipulaciÃ³n de datos en R "
date: "Mayo, 2025"
author: "" 
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      ratio: '16:9'
      countIncrementalSlides: false
      beforeInit: "https://jciturras.github.io/ayudantia-sol3051/slides/00-intro-r/macros.js"
      slideNumberFormat: |
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: calc(%current% / %total% * 100%);">
          </div>
        </div>
    css: ["https://jciturras.github.io/ayudantia-sol3051/slides/00-intro-r/xaringan-coes.css","https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css"]
    seal: false # esto omite title slide automÃ¡tica  
---
layout: true
class: animated, fadeIn

---
class: inverse, left, middle

# _ManipulaciÃ³n de datos en R ğŸ”¢ğŸ”¨ğŸ”§_


MartÃ­n Venegas MÃ¡rquez


***
[Doctorado en PsicologÃ­a UDP - Seminario MetodolÃ³gico Disciplinario: MetodologÃ­as Cuantitativas - OtoÃ±o 2025]()

<br>

#### Mayo, 2025

---
![](input/images/Diapositiva1.PNG)
---
![](input/images/Diapositiva2.PNG)
---
class: inverse, left, middle

# Contenidos de la sesiÃ³n

--

**0. Recordando...**

--

**1. Manejo bÃ¡sico con R Base**

--

**2. Manejo bÃ¡sico de Tidyverse**

--

**3. Manos a la obra**

```{r include=FALSE}
pacman::p_load(tidyverse)
```


---

class: middle, center, inverse

# _0. Recordando..._

---
# Tipos de datos ğŸ”¢ğŸ”¡

| Tipo     | Ejemplo                | DescripciÃ³n |
|----------|------------------------|-------------|
| numeric | `2`, `3.14`            | NÃºmeros reales, con decimales |
| integer   | `4L`                   | NÃºmeros enteros (terminan en `L`) |
| logical   | `TRUE`, `FALSE`        | Valores booleanos (sÃ­ o no, verdadero o falso) |
| character    | `"hola"`              | Cadenas de caracteres |
| factor   | `factor(c("H", "M"))` | Variables categÃ³ricas, usadas comÃºnmente para factores o niveles |
| complex   | `2+3i`, `1-1i`           | NÃºmeros complejos con partes reales e imaginarias |

---
# Estructuras de datos ğŸ§±

| Estructura   | DescripciÃ³n                                                                 | Ejemplo                                  |
|--------------|------------------------------------------------------------------------------|------------------------------------------|
| **vector**   | Secuencia de elementos del mismo tipo                                       | `c(1, 2, 3)`                              |
| **data.frame** | Tabla bidimensional con columnas de distintos tipos                        | `data.frame(nombre = c("Ana", "Luis"), edad = c(25, 30))` |
| **list**     | ColecciÃ³n de objetos de tipos distintos                                      | `list(nombre = "Ana", edad = 30, notas = c(6, 7, 5))` |
| **matrix**   | Arreglo bidimensional con elementos del mismo tipo                          | `matrix(1:6, nrow = 2)`                   |
| **array**    | Arreglo multidimensional (mÃ¡s de 2 dimensiones), todos del mismo tipo        | `array(1:12, dim = c(2, 2, 3))`           |

---
# Estructuras de datos ğŸ§±

![](https://i0.wp.com/balachandark.com/wp-content/uploads/2022/08/dataStructuresNew.png)

---
# Operadores ğŸ”£

| Tipo de operador   | SÃ­mbolos                         | Uso principal                                   | Ejemplo                                         |
| ------------------ | -------------------------------- | ----------------------------------------------- | ----------------------------------------------- | 
| **AritmÃ©ticos**    | `+`, `-`, `*`, `/`, `^`          | Realizan operaciones matemÃ¡ticas bÃ¡sicas        | `3 + 2`, `juan * 2`                             |
| **Relacionales**   | `==`, `!=`, `>`, `<`, `>=`, `<=` | Comparan valores, retornando `TRUE` o `FALSE`   | `ana != 45`, `juan < matias`                    |
| **LÃ³gicos**        | `&`, &#124;, `!`                     | Combinan condiciones booleanas (Y, O, NegaciÃ³n) |  `ana > 30 & juan > 30`                         |
| **De pertenencia** | `%in%`                           | Verifica si un elemento pertenece a un conjunto | `33 %in% c(juan, matiasâ€¦)`                      |

---
# Algunos Ã©nfasis necesarios...

--

### R es _case sensitive_. Es decir, distingue entre mayÃºsculas y minÃºsculas.

--

No es lo mismo

--

```r
objeto <- 1
```

--

A

--

```r
Objeto <- 1
```

---
# Algunos Ã©nfasis necesarios...

--

### El nombrar objetos en R tiene ciertas reglas:

--

- Los nombres pueden contener letra y nÃºmeros, pero siempre deben empezar con una letra. Comenzar un objeto con nÃºmeros o caracteres especiales no es vÃ¡lido. Ej. `2objeto`
  
--

- Los espacios y caracteres especiales deben evitarse. Utilizar "_" para separar palabras. Ej. `objeto_uno` en vez de `objeto uno`
  
--

- Evitar utilizar nombres de funciones como nombres de objetos. Ej. `mean`
  
---
# Algunos Ã©nfasis necesarios...

--

### Si a un objeto se le pone el mismo nombre que otro que ya tengamos, este se sobrescribe y se pierde el anterior. (Siempre definir nombres distintos)

--

```{r}
x <- 4
x

x <- 2
x
```

--

- `x` fue sobreescrito, pasÃ³ de 4 a 2

---
class: middle, center, inverse

# _1. Manejo bÃ¡sico con R Base_

---
# Estructuras fundamentales de acceso ğŸ§±

--

## Retomemos los datos de ejemplo...

--

```{r}
datos <- data.frame(
  persona = c("Juan", "Matias", "Ana", "Leonor", "Sebastian"),
  edad = c(24, 35, 45, 65, 12)
)
```

---
# Estructuras fundamentales de acceso ğŸ§±

--

## `$` (acceso por nombre)

--

- Ãštil para acceder a una columna por nombre en un `data.frame` o `tibble`.

--

- Requiere que el nombre sea vÃ¡lido (sin espacios, ni sÃ­mbolos extraÃ±os).

--

```{r}
datos$edad
```

---
# Estructuras fundamentales de acceso ğŸ§±

--

## `[[]]` (acceso por nombre o posiciÃ³n)

--

- Similar al `$`, pero mÃ¡s flexible (acepta nombres que no son vÃ¡lidos como `datos$"edad promedio"`).

--

- Devuelve el vector completo de esa columna.

```{r}
datos[["edad"]]
datos[[2]]  # Segunda columna
```

---
# Estructuras fundamentales de acceso ğŸ§±

--

## `[,]` (acceso por fila y columna)

--

- Muy poderoso: se usa para seleccionar por posiciÃ³n filas y columnas.

--

- Sintaxis: datos[fila, columna]

--

---
# Estructuras fundamentales de acceso ğŸ§±
## `[,]` (acceso por fila y columna)

```{r}
datos[1, ]       # Primera fila
datos[, 2]       # Segunda columna
```

---
# Estructuras fundamentales de acceso ğŸ§±
## `[,]` (acceso por fila y columna)

```{r}
datos[1:3, 1:2]  # Subconjunto de filas y columnas
```

---

# Estructuras fundamentales de acceso ğŸ§±

--

## `names()` y `colnames()` / `rownames()`

--

- Para obtener o cambiar nombres de columnas o filas.

--

```{r}
names(datos)
colnames(datos)[2] <- "edad_en_anios" # Cambiar nombre a columna 2
datos[["edad_en_anios"]] # Extraer vector de columna renombrada
```

---
# Estructuras fundamentales de acceso ğŸ§±

--

## Sintesis

| Estructura | Devuelve      | Acceso por      | Ãštil para                        |
| ---------- | ------------- | --------------- | -------------------------------- |
| `$`        | Vector        | Nombre vÃ¡lido   | Acceso rÃ¡pido a columnas         |
| `[[]]`     | Vector        | Nombre o Ã­ndice | Nombres no estÃ¡ndar o por Ã­ndice |
| `[ , ]`    | Vector o `df` | Fila y columna  | Subconjuntos mÃ¡s generales       |


---
# Estructuras adicionales Ãºtiles de conocer, pero poco utilizadas en la prÃ¡ctica

--

## `attach()` / `detach()` âš ï¸NO RECOMENDADO

--

- Permiten acceder directamente a variables de un data.frame, pero pueden generar conflictos y no se recomienda su uso en trabajo reproducible.

---
# Funciones bÃ¡sicas en R base ğŸ”¢ğŸ”¨

--
## `sort()` â€” Ordenar vectores

--

- Para ordenar, seleccionar y transformar columnas

--

```{r}
sort(c(3, 1, 4, 1, 5)) # Ordena vectores de menor a mayor.
```
--

- Argumento Ãºtil: `decreasing = TRUE` para ordenar de mayor a menor.

--

```{r}
sort(c(3, 1, 4, 1, 5), decreasing = TRUE)
```

---
# Funciones bÃ¡sicas en R base ğŸ”¢ğŸ”¨

--

## `order()` â€” Ãndices para ordenar

--

```{r}
x <- c(20, 10, 30)
order(x)
```

--

- Devuelve los Ã­ndices que ordenarÃ­an el vector.

--

- Muy Ãºtil para ordenar filas de un `data.frame`:

---
# Funciones bÃ¡sicas en R base ğŸ”¢ğŸ”¨
## `order()` â€” Ãndices para ordenar

--

```{r}
datos # Antes de ordenar
```

--

```{r}
datos[order(datos$edad_en_anios), ] # DespuÃ©s de ordenar
```
---
# Funciones bÃ¡sicas en R base ğŸ”¢ğŸ”¨

--

## `rank()` â€” Rango dentro del vector

--

- Asigna rangos a cada valor.

--

```{r}
rank(c(100, 50, 200))
```

--

- En caso de empates, asigna promedios.

--

```{r}
rank(c(50, 100, 50, 200))
```

---
# Funciones bÃ¡sicas en R base ğŸ”¢ğŸ”¨

--

## `unique()` â€” Valores Ãºnicos

--

```{r}
unique(c(1, 2, 2, 3))
```

--

- Elimina duplicados.

--

- Muy Ãºtil para explorar categorÃ­as de una variable.

---
# Funciones bÃ¡sicas en R base ğŸ”¢ğŸ”¨

--

## `which()` â€” Posiciones de valores lÃ³gicos `TRUE`

--

```{r}
x <- c(10, 20, 30)
which(x > 15)
```

--

- Devuelve los Ã­ndices donde se cumple una condiciÃ³n.

---
# Funciones bÃ¡sicas en R base ğŸ”¢ğŸ”¨

--

### Extra Ãºtil: `seq()` y `rep()`

--

```{r}
seq(1, 10, by = 2)  # Secuencia: 1 3 5 7 9
rep("hola", 3)      # Repetir: "hola" "hola" "hola"
```

--

- ConstrucciÃ³n de vectores para tests o simulaciones.
---
# Funciones bÃ¡sicas en R base ğŸ”¢ğŸ”¨

--

| FunciÃ³n    | Â¿QuÃ© hace?                    | Â¿DÃ³nde se usa?                     |
| ---------- | ----------------------------- | ---------------------------------- |
| `sort()`   | Ordena valores                | Listados ordenados                 |
| `order()`  | Devuelve posiciones ordenadas | Ordenar filas de un `data.frame`   |
| `rank()`   | Asigna rango                  | Ranking de ingresos, edades, etc.  |
| `unique()` | Elimina duplicados            | Explorar categorÃ­as                |
| `which()`  | Ãndices que cumplen condiciÃ³n | Subset, localizaciÃ³n de casos      |
| `seq()`    | Secuencias numÃ©ricas          | Simulaciones, generaciÃ³n de datos  |
| `rep()`    | RepeticiÃ³n                    | ConstrucciÃ³n de vectores           |

---
# Estructuras de programaciÃ³n bÃ¡sicas en R

--

## `if` y `else`: decisiones condicionales

--

```{r}
x <- 10

if (x > 5) {
  print("Mayor que 5")
} else {
  print("Menor o igual a 5")
}
```
--

- `if()` evalÃºa una condiciÃ³n lÃ³gica.

--

- Si es verdadera, ejecuta el cÃ³digo dentro del bloque `{}`.

--

- Si es falsa, se puede usar `else` para ejecutar otra instrucciÃ³n.

---
# Estructuras de programaciÃ³n bÃ¡sicas en R

--

## `ifelse()`: condicional vectorizado

--

```{r}
edades <- c(20, 35, 15)

ifelse(edades >= 18, "adulto", "menor")
```
--

- Aplica condiciones sobre vectores completos.

--

- Ãštil para crear nuevas variables condicionales.
---
# Estructuras de programaciÃ³n bÃ¡sicas en R

--

## `for()`: bucles iterativos

--

```{r}
edades <- c(20, 35, 15) # Creamos vector de edades

for (i in edades) {
  print(i * 2)
}
```
--

- Ejecuta un bloque de cÃ³digo repetidamente para cada valor.

--

- Ãštil para operaciones simples o procesos acumulativos.

---
# Estructuras de programaciÃ³n bÃ¡sicas en R

## `for()`: bucles iterativos

--

Â¿Y si queremos guardar ese vector?

--

```{r}
edades <- c(20, 35, 15) # Creamos vector de edades
dobles <- numeric(length(edades))  # Creamos un vector vacÃ­o del mismo largo

for (i in 1:length(edades)) {
  dobles[i] <- edades[i] * 2
}

dobles
```

---
# Estructuras de programaciÃ³n bÃ¡sicas en R

--

## `while()`: repite mientras se cumpla una condiciÃ³n

--

```{r}
x <- 1

while (x < 5) {
  print(x)
  x <- x + 1
}
```

--

- Mientras la condiciÃ³n se mantenga verdadera, ejecuta el cÃ³digo dentro de los `{}`

--

- Menos usado que `for()`, pero Ãºtil si no sabes cuÃ¡ntas iteraciones necesitas.

---
# Estructuras de programaciÃ³n bÃ¡sicas en R

--

## `next` y `break`: control de flujo en bucles

--

```{r}
for (i in 1:5) {
  if (i == 3) next   # salta la iteraciÃ³n si i == 3
  print(i)
}

for (i in 1:5) {
  if (i == 3) break  # corta el bucle si i == 3
  print(i)
}

```


---
# Estructuras de programaciÃ³n bÃ¡sicas en R

--

## Funciones propias: generalizar cÃ³digo

--

```{r}
# Crear funciÃ³n
multiplicar_por_dos <- function(x) {
  return(x*2)
} 

edades <- c(20, 35, 15) # Crear vector de edades

multiplicar_por_dos(edades) # Aplicar funciÃ³n

```

--

- Dentro de `function()` se plantean los parametros

--

- Dentro de `{}` se explicita el comportamiento de la funciÃ³n

---
# Estructuras de programaciÃ³n bÃ¡sicas en R

--

## Funciones propias: a nuestro criterio

--

```{r}
multiplicar_por_dos <- function(x) {
  if(is.numeric(x)){
    return(x*2)
  } else {
    print("Â¡ERROR! El vector debe ser nÃºmerico")
  }

}

```

--

- AÃ±adamos una condiciÃ³n: para que la funciÃ³n se aplique correctamente, el vector debe ser nÃºmerico

--

- Si el vector es nÃºmerico, entonces que aplique la funciÃ³n

--

- Si el vector no es nÃºmerico, que entregue un mensaje de error

---

# Estructuras de programaciÃ³n bÃ¡sicas en R

--

## Funciones propias: a nuestro criterio

--

```{r}
edades <- c(20, 35, 15) # Crear vector de edades
edades_character <- c("20", "35", "15") # Crear vector de edades en character
```

--

```{r}
multiplicar_por_dos(edades)
multiplicar_por_dos(edades_character)
```

---

# Estructuras de programaciÃ³n bÃ¡sicas en R

| Estructura   | Usos                                     |
| ------------ | ------------------------------------------------- |
| `if / else`  | Aplicar lÃ³gica binaria (mayores de edad, etc.) |
| `ifelse()`   | RecodificaciÃ³n vectorial (sexo, regiones, etc.)   |
| `for`        | Automatizar tareas repetitivas                    |
| `while`      | Evaluar condiciones dinÃ¡micas                     |
| `next`       | Saltar casos especÃ­ficos (ej. valores perdidos)   |
| `break`      | Cortar ejecuciÃ³n si hay un error                  |
| `function()` | EncapsulaciÃ³n y reutilizaciÃ³n del cÃ³digo  |

---
class: middle, center, inverse

# _2. Manejo bÃ¡sico con tidyverse_
---
# Usando dplyr ğŸ”§

##  Operador *pipe* `%>%`

.left-column[

- La herramienta nÃºmero uno de `dplyr` (y `tidyverse` en general)

- El *pipe* (`%>%`) es un **operador** que nos permite **encadenar funciones** de manera mÃ¡s legible y ordenada.

- Se puede leer como: **"y luego"**. Es decir, el resultado de una operaciÃ³n se pasa como primer argumento a la siguiente.
]

.center[.right-column[

![](input/images/pipe-logo.png)

]]

---
.center[![](input/images/pipes.png)]
---
# Usando dplyr ğŸ”§
##  Operador *pipe* `%>%`

--

 ğŸ“Œ Ejemplo sin *pipe*:

```r
filter(arrange(select(df, var1, var2), var1), var2 > 5)
```

--

ğŸ“Œ Ejemplo con pipe:

```r
df %>%
  select(var1, var2) %>%
  arrange(var1) %>%
  filter(var2 > 5)
```

---
# Usando dplyr ğŸ”§
##  Operador *pipe* `%>%`

--

âœ… Ventajas:

--

- MÃ¡s legibilidad y lÃ³gica paso a paso

--

- Facilita el _debugging_ (probar parte por parte)

--

- Fomenta un cÃ³digo mÃ¡s declarativo (lo que quiero hacer, no cÃ³mo)
---
# Usando dplyr ğŸ”§

--

## Retomemos los datos de ejemplo... y adaptemoslos

--

```{r}
datos <- data.frame(
  persona = c("Juan", "Matias", "Ana", "Leonor", "Sebastian"),
  edad = c(24, 35, 45, 65, 12),
  sexo = c("Hombre", "Hombre", "Mujer", "Mujer", "Hombre"),
  ingresos = c(1000000, 800000, 1300000, 1500000, 0),
  region = c("Metropolitana", "Metropolitana", "Valparaiso", "Valparaiso", "Antofagasta")
)
```

---
# Usando dplyr ğŸ”§

--

## `select()`

.left-column[

- Permite seleccionar columnas especÃ­ficas de un dataframe.

- Ãštil para reducir la base a solo las variables necesarias.

```{r}
datos %>% select(edad, sexo)
```
]


.right-column[
![](input/images/select.png)
]
---
# Usando dplyr ğŸ”§

## `select()`

--

- Existen muchas formas de seleccionar las columnas de un dataframe

--

- Puede ser por nombre de variables, rangos, exclusiones, etc.

--

- Por ejemplo...

--

```{r}
datos %>% select(edad:ingresos) # SelecciÃ³n por rangos
```

---
# Usando dplyr ğŸ”§

## `select()`

- Existen muchas formas de seleccionar las columnas de un dataframe

- Puede ser por nombre de variables, rangos, exclusiones, etc.

- Por ejemplo...

```{r}
datos %>% select(-sexo) # SelecciÃ³n por exclusiÃ³n de sexo
```

---
# Usando dplyr ğŸ”§

| MÃ©todo                    | Ejemplo                                 | DescripciÃ³n                                                                          |
| ------------------------- | --------------------------------------- | ------------------------------------------------------------------------------------ |
| SelecciÃ³n directa         | `select(var1, var2)`                | Selecciona columnas por nombre explÃ­cito.                                            |
| Rango de variables        | `select(var1:var5)`                 | Selecciona todas las columnas desde `var1` hasta `var5`.                             |
| `starts_with()`           | `select(starts_with("ing"))`        | Selecciona columnas cuyos nombres comienzan con cierto texto.                        |
| `ends_with()`             | `select(ends_with("_cat"))`         | Selecciona columnas cuyos nombres terminan con cierto texto.                         |
| `contains()`              | `select(contains("edad"))`          | Selecciona columnas cuyos nombres contienen cierto texto.                            |

---
# Usando dplyr ğŸ”§


| MÃ©todo                    | Ejemplo                                 | DescripciÃ³n                                                                          |
| ------------------------- | --------------------------------------- | ------------------------------------------------------------------------------------ |
| `matches()`               | `select(matches("^var[0-9]+$"))`    | Selecciona columnas que cumplan con una expresiÃ³n regular.                           |
| `all_of()`                | `select(all_of(c("var1", "var2")))` | Selecciona un conjunto de columnas que estÃ¡n en un vector. Da error si falta alguna. |
| `any_of()`                | `select(any_of(c("var1", "varX")))` | Igual que `all_of()`, pero **ignora** las que no existen.                            |
| ExclusiÃ³n (`-`)           | `select(-var1)`                     | Excluye una columna especÃ­fica.                                                      |
| CombinaciÃ³n de selectores | `select(starts_with("p"), -p10)`    | CombinaciÃ³n flexible de condiciones.                                                 |

---
# Usando dplyr ğŸ”§

--

## `rename()`

--

- Renombra columnas de forma directa.

--

- Ideal para mejorar la legibilidad de nombres tÃ©cnicos.

--

```{r}
datos %>% rename(edad_respondente = edad)
```

---
# Usando dplyr ğŸ”§

--

## `filter()`

--

- Filtra filas segÃºn condiciones lÃ³gicas.

--

- Para crear subconjuntos de la base.

--

- Â¡AquÃ­ serÃ¡n especialmente Ãºtiles los operadores relacionales y lÃ³gicos!

```{r}
datos %>% filter(sexo == "Mujer" & edad > 30)
```
---
# Usando dplyr ğŸ”§

--

## `mutate()`

--

- Crea nuevas columnas o transforma columnas existentes.

--

- Ideal para generar nuevas variables derivadas.

--

```{r}
datos %>% mutate(edad2 = edad^2)
```

---
# Usando dplyr ğŸ”§

--

## `case_when()`

--

- Permite recodificar valores en base a condiciones.

--

- MÃ¡s legible y potente que `ifelse()` para mÃºltiples condiciones.

--

```{r}
datos %>% mutate(rango_edad = case_when(
  edad < 18 ~ "menor de edad",
  edad >= 18 & edad < 60 ~ "adulto",
  edad >= 60 ~ "adulto mayor"
))

```

---
# Usando dplyr ğŸ”§

--

## `group_by()` + `summarise()`

--

- `group_by()` permite hacer operaciones en base a las categorÃ­as de una variable categÃ³rica

--

- Su principal utilidad recae en hacer resumenes estadÃ­sticos por grupo a travÃ©s de `summarise()`

```{r}
datos %>% group_by(sexo) %>% summarise(media_ingresos = mean(ingresos))
```

---
## `group_by()`
![](input/images/group_by.png)
---
## `group_by()` + `summarise()`
.![:scale 50%](input/images/summarise.png)

---
# Usando dplyr ğŸ”§

--

## `distinct()`

--

- Entrega solo las filas Ãºnicas (sin duplicados).

--

- Muy Ãºtil para explorar niveles de una variable categÃ³rica.

--

```{r}
datos %>% distinct(sexo)
```

---
# Usando dplyr ğŸ”§

--

## `relocate()`

--

- Cambia el orden de las columnas.

--

- Mejora la organizaciÃ³n del dataset.

--

```{r}
datos %>% relocate(edad, .after = sexo)
```
---

# Usando dplyr ğŸ”§

--

## `arrange()`

--

- Ordena las filas por una o mÃ¡s variables.

--

- Puedes ordenar ascendente o descendente.

--

```{r}
datos %>% arrange(edad) # Ascendente (por defecto)
```

---
# Usando dplyr ğŸ”§

--

## `arrange()`

--

- Ordena las filas por una o mÃ¡s variables.

--

- Es posible ordenar de manera ascendente o descendente.

--

```{r}
datos %>% arrange(desc(ingresos)) # Descendente
```

---
## Un resumen visual ğŸ‘€

.center[![](input/images/dplyr.png)]
---
# Usando dplyr ğŸ”§

--

## Joins ğŸ—ï¸

- Las bases de datos complejas suelen estar divididas en varias tablas.

--

- Por ejemplo: una tabla de personas y otra de hogares.

--

- Los **joins** nos permiten cruzar estas tablas segÃºn una clave comÃºn.

--

- Evitamos duplicaciÃ³n y facilitamos el anÃ¡lisis modular de datos.

---

# Usando dplyr ğŸ”§

## Joins ğŸ—ï¸


| FunciÃ³n          | Â¿QuÃ© hace?                                                    |
|------------------|---------------------------------------------------------------|
| `left_join()`    | Mantiene todas las filas de la tabla base (izquierda).        |
| `right_join()`   | Mantiene todas las filas de la tabla secundaria (derecha).    |
| `inner_join()`   | Solo mantiene coincidencias en ambas tablas.                  |
| `full_join()`    | Une todas las filas de ambas tablas, completa con `NA`.       |


Usan una **clave comÃºn** (`by = "id"`).

---
.center[![:scale 65%](input/images/joins.png)]
---

# Usando dplyr ğŸ”§

- Recordemos nuestros datos

```{r}
datos
```

---
# Usando dplyr ğŸ”§

- Creemos una tabla con informaciÃ³n a nivel de regiÃ³n:

```{r}
regiones <- data.frame(
  region = c("Arica", "Tarapaca", "Antofagasta", "Atacama", "Coquimbo", "Valparaiso", "Metropolitana", "O'Higgins", "Maule", "Nuble", "Biobio", "Araucania", "Los Rios", "Los Lagos", "Aysen", "Magallanes"),
  vict = c(31.7, 33.9, 18.7, 11.8, 17.8, 19.4, 27.7, 18.0, 14.2, 14.3, 14.3, 12.6, 22.0, 15.9, 8.7, 3.9)
)
regiones
```

---
## `left_join()` ğŸ—ï¸â¬…ï¸

```{r}
left_join(datos, regiones)
```
---
## `right_join()` ğŸ—ï¸â¡ï¸

```{r}
right_join(datos, regiones)
```
---

## `inner_join()` ğŸ—ï¸ğŸ”€

```{r}
inner_join(datos, regiones)
```

---

## `full_join()` ğŸ—ï¸ğŸ”„ï¸

```{r}
full_join(datos, regiones)
```
---

class: middle, center, inverse

# _3. Manos a la obra._

---
# Ejercicio prÃ¡ctico

--

(1) Cargue el set de datos de la [Encuesta Nacional de Salud, Sexualidad y GÃ©nero 2023](https://datos.gob.cl/dataset/encuesta-nacional-de-salud-sexualidad-y-genero-enssex-2022-2023/resource/ed81f50c-1c7d-43d9-9083-dfc161e0cd66)

--

(2) Seleccione las variables de edad (`p4`), sexo (`p1`), regiÃ³n (`region`), calidad de vida (`p8`), percepciÃ³n de salud (`p10`). Use `select()`.

--

(3) Renombre las variables escogidas por nombres mÃ¡s sustantivos. Use `rename()`.

--

(4) Cree una nueva variable llamada `edad_tramos`, siguiendo los tramos de 18-24, 25-34, 35-44, 45-54, 55-54, +64 aÃ±os. Use `mutate()` y `case_when()`.

---
# Ejercicio prÃ¡ctico

(5) Filtre el dataset por los individuos que no se encuentren en el tramo de 18-24 aÃ±os. Use `filter()`.

--

(6) Genere una tabla con la media de las percepciones de salud a nivel regiÃ³n y guÃ¡rdela en un nuevo objeto. Use `group_by()`, `summarise()` y `ungroup()`.

--

(7) Haga un join entre el dataset a nivel de personas y la tabla de la media de percepciÃ³n de salud por regiÃ³n. Utilice `left_join`

--

(8) Ordene las filas del dataset por edad ascendente. Utilice `arrange()`

---
# Algunos recursos...ğŸ¤“

### (1) [PÃ¡gina de dplyr](https://dplyr.tidyverse.org/)

### (2) [Cheeatsheet dplyr](https://nyu-cdsc.github.io/learningr/assets/data-transformation.pdf)

### (3) [Tutoriales R coder](https://r-coder.com/select-dplyr-en-r/)


---

class: middle, center, inverse

# _Â¡Muchas gracias!_
