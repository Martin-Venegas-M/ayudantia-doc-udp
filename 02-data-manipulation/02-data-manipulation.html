<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R Básico: comenzando un viaje</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <script src="libs/header-attrs-2.26/header-attrs.js"></script>
    <link rel="stylesheet" href="https://jciturras.github.io/ayudantia-sol3051/slides/00-intro-r/xaringan-coes.css" type="text/css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

layout: true
class: animated, fadeIn

---
class: inverse, left, middle

# _Manipulación de datos en R_


Martín Venegas Márquez


***
[Doctorado en Psicología UDP - Seminario Metodológico Disciplinario: Metodologías Cuantitativas - Otoño 2025]()

&lt;br&gt;

#### Mayo, 2025

---
class: inverse, left, middle

# Contenidos de la sesión

--

**0. Recordando...**

--

**1. Manejo básico con R Base**

--

**2. Manejo básico de Tidyverse**

--

**3. Manos a la obra**

---

class: middle, center, inverse

# _0. Recordando..._


---
class: middle, center, inverse

# _1. Manejo básico con R Base_

---
# Estructuras fundamentales para acceder y manipular datos

--

## Retomemos los datos de ejemplo...

--


```r
datos &lt;- data.frame(
  persona = c("Juan", "Matias", "Ana", "Leonor", "Sebastian"),
  edad = c(24, 35, 45, 65, 12)
)
```

---
# Etructuras fundamentales para acceder y manipular datos

--

## `$` (acceso por nombre)

--

- Útil para acceder a una columna por nombre en un `data.frame` o `tibble`.

--

- Requiere que el nombre sea válido (sin espacios, ni símbolos extraños).

--


```r
datos$edad
```

```
## [1] 24 35 45 65 12
```

---
# Etructuras fundamentales para acceder y manipular datos

--

## `[[]]` (acceso por nombre o posición)

--

- Similar al `$`, pero más flexible (acepta nombres que no son válidos como `datos$"edad promedio"`).

--

- Devuelve el vector completo de esa columna.


```r
datos[["edad"]]
```

```
## [1] 24 35 45 65 12
```

```r
datos[[2]]  # Segunda columna
```

```
## [1] 24 35 45 65 12
```

---
# Etructuras fundamentales para acceder y manipular datos

--

## `[,]` (acceso por fila y columna)

--

- Muy poderoso: se usa para seleccionar por posición filas y columnas.

--

- Sintaxis: datos[fila, columna]

--

---
# Etructuras fundamentales para acceder y manipular datos
## `[,]` (acceso por fila y columna)


```r
datos[1, ]       # Primera fila
```

```
##   persona edad
## 1    Juan   24
```

```r
datos[, 2]       # Segunda columna
```

```
## [1] 24 35 45 65 12
```

---
# Etructuras fundamentales para acceder y manipular datos
## `[,]` (acceso por fila y columna)


```r
datos[1:3, 1:2]  # Subconjunto de filas y columnas
```

```
##   persona edad
## 1    Juan   24
## 2  Matias   35
## 3     Ana   45
```

---

# Etructuras fundamentales para acceder y manipular datos

--

## `names()` y `colnames()` / `rownames()`

--

- Para obtener o cambiar nombres de columnas o filas.

--


```r
names(datos)
```

```
## [1] "persona" "edad"
```

```r
colnames(datos)[2] &lt;- "edad_en_anios" # Cambiar nombre a columna 2
datos[["edad_en_anios"]] # Extraer vector de columna renombrada
```

```
## [1] 24 35 45 65 12
```

---
# Estructuras fundamentales para acceder y manipular datos

--

## Sintesis

| Estructura | Devuelve      | Acceso por      | Útil para                        |
| ---------- | ------------- | --------------- | -------------------------------- |
| `$`        | Vector        | Nombre válido   | Acceso rápido a columnas         |
| `[[]]`     | Vector        | Nombre o índice | Nombres no estándar o por índice |
| `[ , ]`    | Vector o `df` | Fila y columna  | Subconjuntos más generales       |


---
# Estructuras adicionales útiles de conocer, pero poco utilizadas en la práctica

--

## `attach()` / `detach()` ⚠️NO RECOMENDADO

--

- También permiten acceder directamente a variables de un data.frame, pero pueden generar conflictos y no se recomienda su uso en trabajo reproducible.

---
# Estructuras adicionales útiles de conocer, pero poco utilizadas en la práctica

--

# `with()` / `within()`

--

- Permiten acceder a variables dentro de un data.frame sin repetir $.

--

- En términos técnicos, evaluan una expresión dentro de un `data.frame`

--

- `with()` solo entrega el output de la expresión

--

- `within()` permite crear columnas dentro del `data.frame`

--

```r
with(datos, edad)
```
---
# Funciones básicas en R base

--
## `sort()` — Ordenar vectores

--

- Para ordenar, seleccionar y transformar columnas

--


```r
sort(c(3, 1, 4, 1, 5)) # Ordena vectores de menor a mayor.
```

```
## [1] 1 1 3 4 5
```
--

- Argumento útil: `decreasing = TRUE` para ordenar de mayor a menor.

--


```r
sort(c(3, 1, 4, 1, 5), decreasing = TRUE)
```

```
## [1] 5 4 3 1 1
```

---
# Funciones básicas en R base

--

## `order()` — Índices para ordenar

--


```r
x &lt;- c(20, 10, 30)
order(x)
```

```
## [1] 2 1 3
```

--

- Devuelve los índices que ordenarían el vector.

--

- Muy útil para ordenar filas de un `data.frame`:

---
# Funciones básicas en R base
## `order()` — Índices para ordenar

--


```r
datos # Antes de ordenar
```

```
##     persona edad_en_anios
## 1      Juan            24
## 2    Matias            35
## 3       Ana            45
## 4    Leonor            65
## 5 Sebastian            12
```

--


```r
datos[order(datos$edad_en_anios), ] # Después de ordenar
```

```
##     persona edad_en_anios
## 5 Sebastian            12
## 1      Juan            24
## 2    Matias            35
## 3       Ana            45
## 4    Leonor            65
```
---
# Funciones básicas en R base

--

## `rank()` — Rango dentro del vector

--


```r
rank(c(100, 50, 200))
```

```
## [1] 2 1 3
```

--

- Asigna rangos a cada valor.

--

- En caso de empates, asigna promedios.

---
# Funciones básicas en R base

--

## `unique()` — Valores únicos

--


```r
unique(c(1, 2, 2, 3))
```

```
## [1] 1 2 3
```

--

- Elimina duplicados.

--

- Muy útil para explorar categorías de una variable.

---
# Funciones básicas en R base

--

## `table()` — Frecuencia de valores

--


```r
table(c("hombre", "mujer", "mujer"))
```

```
## 
## hombre  mujer 
##      1      2
```

--

- Devuelve una tabla de frecuencias absolutas.

--

- Se puede aplicar a columnas de un data.frame.

---
# Funciones básicas en R base

--

## `which()` — Posiciones de valores lógicos TRUE

--


```r
x &lt;- c(10, 20, 30)
which(x &gt; 15)
```

```
## [1] 2 3
```

--

- Devuelve los índices donde se cumple una condición.

---
# Funciones básicas en R base

--

## `subset()` — Filtrar filas

--

```r
subset(datos, edad &gt; 30)
```

--

- Atajo para filtrar datos sin usar [].

--

- Más legible que datos[datos$edad &gt; 30, ], pero menos flexible.

---
# Funciones básicas en R base

--

## `ifelse()` — Evaluación condicional

--


```r
ifelse(datos$edad &gt; 30, "mayor", "menor o igual")
```

```
## [1] "menor o igual" "mayor"         "mayor"         "mayor"        
## [5] "menor o igual"
```

--

- Crea vectores condicionales.

--

- Ideal para recodificaciones simples.

---
# Funciones básicas en R base

--

### Extra útil: `seq()` y `rep()`

--


```r
seq(1, 10, by = 2)  # Secuencia: 1 3 5 7 9
```

```
## [1] 1 3 5 7 9
```

```r
rep("hola", 3)      # Repetir: "hola" "hola" "hola"
```

```
## [1] "hola" "hola" "hola"
```

--

- Construcción de vectores para tests o simulaciones.
---
# Funciones básicas en R base

--

| Función    | ¿Qué hace?                    | ¿Dónde se usa?                     |
| ---------- | ----------------------------- | ---------------------------------- |
| `sort()`   | Ordena valores                | Listados ordenados                 |
| `order()`  | Devuelve posiciones ordenadas | Ordenar filas de un `data.frame`   |
| `rank()`   | Asigna rango                  | Ranking de ingresos, edades, etc.  |
| `unique()` | Elimina duplicados            | Explorar categorías                |
| `table()`  | Frecuencia                    | Distribución de respuestas         |
| `which()`  | Índices que cumplen condición | Subset, localización de casos      |
| `subset()` | Filtra datos                  | Alternativa a `[]` con condiciones |
| `ifelse()` | Evaluación condicional        | Recodificación de columnas         |
| `seq()`    | Secuencias numéricas          | Simulaciones, generación de datos  |
| `rep()`    | Repetición                    | Construcción de vectores           |

---
# Estructuras de programación básicas en R

--

## `if` y `else`: decisiones condicionales

--


```r
x &lt;- 10

if (x &gt; 5) {
  print("Mayor que 5")
} else {
  print("Menor o igual a 5")
}
```

```
## [1] "Mayor que 5"
```
--

- `if()` evalúa una condición lógica.

--

- Si es verdadera, ejecuta el código dentro del bloque `{}`.

--

- Si es falsa, se puede usar `else` para ejecutar otra instrucción.

---
# Estructuras de programación básicas en R

--

## `ifelse()`: condicional vectorizado

--


```r
edades &lt;- c(20, 35, 15)

ifelse(edades &gt;= 18, "adulto", "menor")
```

```
## [1] "adulto" "adulto" "menor"
```
--

- Aplica condiciones sobre vectores completos.

--

- Útil para crear nuevas variables condicionales.
---
# Estructuras de programación básicas en R

--

## `for()`: bucles iterativos

--


```r
edades &lt;- c(20, 35, 15) # Creamos vector de edades

for (i in edades) {
  print(i * 2)
}
```

```
## [1] 40
## [1] 70
## [1] 30
```
--

- Ejecuta un bloque de código repetidamente para cada valor.

--

- Útil para operaciones simples o procesos acumulativos.

---
# Estructuras de programación básicas en R

## `for()`: bucles iterativos

--

¿Y si queremos guardar ese vector?

--


```r
edades &lt;- c(20, 35, 15) # Creamos vector de edades
dobles &lt;- numeric(length(edades))  # Creamos un vector vacío del mismo largo

for (i in 1:length(edades)) {
  dobles[i] &lt;- edades[i] * 2
}

dobles
```

```
## [1] 40 70 30
```

---
# Estructuras de programación básicas en R

--

## `while()`: repite mientras se cumpla una condición

--


```r
x &lt;- 1

while (x &lt; 5) {
  print(x)
  x &lt;- x + 1
}
```

```
## [1] 1
## [1] 2
## [1] 3
## [1] 4
```

--

- Mientras la condición se mantenga verdadera, ejecuta el código dentro de los `{}`

--

- Menos usado que `for()`, pero útil si no sabes cuántas iteraciones necesitas.

---
# Estructuras de programación básicas en R

--

## `next` y `break`: control de flujo en bucles

--


```r
for (i in 1:5) {
  if (i == 3) next   # salta la iteración si i == 3
  print(i)
}
```

```
## [1] 1
## [1] 2
## [1] 4
## [1] 5
```

```r
for (i in 1:5) {
  if (i == 3) break  # corta el bucle si i == 3
  print(i)
}
```

```
## [1] 1
## [1] 2
```


---
# Estructuras de programación básicas en R

--

## Funciones propias: reutilizar código

--


```r
# Crear función
multiplicar_por_dos &lt;- function(x) {
  return(x*2)
} 

edades &lt;- c(20, 35, 15) # Crear vector de edades

multiplicar_por_dos(edades) # Aplicar función
```

```
## [1] 40 70 30
```

--

- Dentro de `function()` se plantean los parametros

--

- Dentro de `{}` se explicita el comportamiento de la función

---
# Estructuras de programación básicas en R

--

## Funciones propias: a nuestro criterio

--


```r
multiplicar_por_dos &lt;- function(x) {
  if(is.numeric(x)){
    return(x*2)
  } else {
    print("¡ERROR! El vector debe ser númerico")
  }

}
```

--

- Añadamos una condición: para que la función se aplique correctamente, el vector debe ser númerico

--

- Si el vector es númerico, entonces que aplique la función

--

- Si el vector no es númerico, que entregue un mensaje de error

---

# Estructuras de programación básicas en R

--

## Funciones propias: a nuestro criterio

--


```r
edades &lt;- c(20, 35, 15) # Crear vector de edades
edades_character &lt;- c("20", "35", "15") # Crear vector de edades en character
```

--


```r
multiplicar_por_dos(edades)
```

```
## [1] 40 70 30
```

```r
multiplicar_por_dos(edades_character)
```

```
## [1] "¡ERROR! El vector debe ser númerico"
```

---

# Estructuras de programación básicas en R

| Estructura   | Usos                                     |
| ------------ | ------------------------------------------------- |
| `if / else`  | Aplicar lógica binaria (mayores de edad, etc.) |
| `ifelse()`   | Recodificación vectorial (sexo, regiones, etc.)   |
| `for`        | Automatizar tareas repetitivas                    |
| `while`      | Evaluar condiciones dinámicas                     |
| `next`       | Saltar casos específicos (ej. valores perdidos)   |
| `break`      | Cortar ejecución si hay un error                  |
| `function()` | Encapsulación y reutilización del código  |
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="https://jciturras.github.io/ayudantia-sol3051/slides/00-intro-r/macros.js"></script>
<script>var slideshow = remark.create({
  "ratio": "16:9",
  "countIncrementalSlides": false,
  "slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>\n"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
